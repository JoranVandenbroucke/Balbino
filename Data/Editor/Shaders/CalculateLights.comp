#version 450
#include "CommonInclude.glsl"

#ifndef BLOCK_SIZE
#pragma message( "BLOCK_SIZE undefined. Default to 16.")
#define BLOCK_SIZE 16// should be defined by the application.
#endif

// Global variables
layout(std430, set = 1, binding = 0)readonly buffer DispatchParams
{
// Number of groups dispatched. (This parameter is not available as an HLSL system value!)
    uvec3   numThreadGroups;
// uint padding // implicit padding to 16 bytes.

// Total number of threads dispatched. (Also not available as an HLSL system value!)
// Note: This value may be less than the actual number of threads executed
// if the screen size is not evenly divisible by the block size.
    uvec3   numThreads;
// uint padding // implicit padding to 16 bytes.
};

// The depth from the screen space texture.
layout (rgba32f, binding = 1) uniform image2D DepthTextureVS;
// Precomputed frustums for the grid.
layout(std430, set = 1, binding = 2) buffer iFrustums
{
    Frustum in_Frustums[];
} inFrustrum;

// Global counter for current index into the light index list.
// "o_" prefix indicates light lists for opaque geometry while
// "t_" prefix indicates light lists for transparent geometry.
coherent layout(std430, set = 1, binding = 2) buffer oLightIndexCounter{
    uint o_LightIndexCounter[];
} OLightIndexCounter;
coherent layout(std430, set = 1, binding = 3) buffer tLightIndexCounter{
    uint t_LightIndexCounter[];
} TLightIndexCounter;

// Light index lists and light grids.
layout(std430, set = 1, binding = 4) writeonly buffer oLightIndexList{
    uint o_LightIndexList[];
}OLightIndexList;
layout(std430, set = 1, binding = 5) writeonly buffer tLightIndexList{
    uint t_LightIndexList[];
}TLightIndexList;
layout(rg16ui, binding = 6) uniform uimage2D o_LightGrid;
layout(rg16ui, binding = 7) uniform uimage2D t_LightGrid;
layout(std430, set = 1, binding = 8) buffer lights{
    Light Lights[];
}lightList;
shared uint uMinDepth;
shared uint uMaxDepth;

shared Frustum GroupFrustum;

// Opaque geometry light lists.
shared uint o_LightCount;
shared uint o_LightIndexStartOffset;
shared uint o_LightList[1024];

// Transparent geometry light lists.
shared uint t_LightCount;
shared uint t_LightIndexStartOffset;
shared uint t_LightList[1024];

// Add the light to the visible light list for opaque geometry.
void o_AppendLight(uint lightIndex)
{
    uint index;// Index into the visible lights array.
    index = atomicAdd(o_LightCount, 1);
    if (index < 1024)
    {
        o_LightList[index] = lightIndex;
    }
}

// Add the light to the visible light list for transparent geometry.
void t_AppendLight(uint lightIndex)
{
    uint index;// Index into the visible lights array.
    index = atomicAdd(t_LightCount, 1);
    if (index < 1024)
    {
        t_LightList[index] = lightIndex;
    }
}

// Implementation of light culling compute shader is based on the presentation
// "DirectX 11 Rendering in Battlefield 3" (2011) by Johan Andersson, DICE.
// Retrieved from: http://www.slideshare.net/DICEStudio/directx-11-rendering-in-battlefield-3
// Retrieved: July 13, 2015
// And "Forward+: A Step Toward Film-Style Shading in Real Time", Takahiro Harada (2012)
// published in "GPU Pro 4", Chapter 5 (2013) Taylor & Francis Group, LLC.
layout(local_size_x = BLOCK_SIZE, local_size_y = BLOCK_SIZE, local_size_z = BLOCK_SIZE)in;
void main()
{
    uvec3 groupID           = gl_WorkGroupID;// 3D index of the thread group in the dispatch.
    uvec3 groupThreadID     = gl_LocalInvocationID;// 3D index of local thread ID in a thread group.
    uvec3 dispatchThreadID  = gl_GlobalInvocationID;// 3D index of global thread ID in the dispatch.
    uint  groupIndex        = gl_LocalInvocationIndex;// Flattened local index of the thread within a thread group.
    
    // Calculate min & max depth in threadgroup / tile.
    ivec2 texCoord = ivec2(dispatchThreadID.x, dispatchThreadID.y);
    float fDepth = imageLoad(DepthTextureVS, texCoord).r;
    
    uint uDepth = floatBitsToUint(fDepth);
    
    if (groupIndex == 0)// Avoid contention by other threads in the group.
    {
        uMinDepth = 0xffffffff;
        uMaxDepth = 0;
        o_LightCount = 0;
        t_LightCount = 0;
        GroupFrustum = inFrustrum.in_Frustums[groupID.x + (groupID.y * numThreadGroups.x)];
    }
    
    groupMemoryBarrier();
    barrier();
    
    uMinDepth = atomicMin(uMinDepth, uDepth);
    uMaxDepth = atomicMax(uMaxDepth, uDepth);
    
    groupMemoryBarrier();
    barrier();
    
    float fMinDepth = uintBitsToFloat(uMinDepth);
    float fMaxDepth = uintBitsToFloat(uMaxDepth);
    
    // Convert depth values to view space.
    float minDepthVS = ClipToView(vec4(0, 0, fMinDepth, 1)).z;
    float maxDepthVS = ClipToView(vec4(0, 0, fMaxDepth, 1)).z;
    float nearClipVS = ClipToView(vec4(0, 0, 0, 1)).z;
    
    // Clipping plane for minimum depth value
    // (used for testing lights within the bounds of opaque geometry).
    Plane minPlane = Plane(vec3(0, 0, -1), -minDepthVS);
    
    // Cull lights
    // Each thread in a group will cull 1 light until all lights have been culled.
    for (uint i = groupIndex; i < NUM_LIGHTS; i += BLOCK_SIZE * BLOCK_SIZE)
    {
        if (lightList.Lights[i].Enabled)
        {
            Light light = lightList.Lights[i];
            
            switch (light.Type)
            {
                case POINT_LIGHT:
                {
                    Sphere sphere = Sphere(light.PositionVS.xyz, light.Range);
                    if (SphereInsideFrustum(sphere, GroupFrustum, nearClipVS, maxDepthVS))
                    {
                        // Add light to light list for transparent geometry.
                        t_AppendLight(i);
                        
                        if (!SphereInsidePlane(sphere, minPlane))
                        {
                            // Add light to light list for opaque geometry.
                            o_AppendLight(i);
                        }
                    }
                }
                break;
                
                case SPOT_LIGHT:
                {
                    float coneRadius = tan(radians(light.SpotlightAngle)) * light.Range;
                    Cone cone = Cone(light.PositionVS.xyz, light.Range, light.DirectionVS.xyz, coneRadius);
                    if (ConeInsideFrustum(cone, GroupFrustum, nearClipVS, maxDepthVS))
                    {
                        // Add light to light list for transparent geometry.
                        t_AppendLight(i);
                        
                        if (!ConeInsidePlane(cone, minPlane))
                        {
                            // Add light to light list for opaque geometry.
                            o_AppendLight(i);
                        }
                    }
                }
                break;
                
                case DIRECTIONAL_LIGHT:
                {
                    // Directional lights always get added to our light list.
                    // (Hopefully there are not too many directional lights!)
                    t_AppendLight(i);
                    o_AppendLight(i);
                }
                break;
            }
        }
    }
    
    // Wait till all threads in group have caught up.
    groupMemoryBarrier();
    barrier();
    
    // Update global memory with visible light buffer.
    // First update the light grid (only thread 0 in group needs to do this)
    if (groupIndex == 0)
    {
        // Update light grid for opaque geometry.
        o_LightIndexStartOffset = atomicAdd(OLightIndexCounter.o_LightIndexCounter[0], o_LightCount);
        imageStore(o_LightGrid, ivec2(groupID.xy), uvec4(o_LightIndexStartOffset, o_LightCount, 0, 0));
        
        // Update light grid for transparent geometry.
        t_LightIndexStartOffset = atomicAdd(TLightIndexCounter.t_LightIndexCounter[0], t_LightCount);
        imageStore(t_LightGrid, ivec2(groupID.xy), uvec4(t_LightIndexStartOffset, t_LightCount, 0, 0));
    }
    
    groupMemoryBarrier();
    barrier();
    
    // Now update the light index list (all threads).
    // For opaque geometry.
    for (uint i = groupIndex; i < o_LightCount; i += BLOCK_SIZE * BLOCK_SIZE)
    {
        OLightIndexList.o_LightIndexList[o_LightIndexStartOffset + i] = o_LightList[i];
    }
    // For transparent geometry.
    for (uint i = groupIndex; i < t_LightCount; i += BLOCK_SIZE * BLOCK_SIZE)
    {
        TLightIndexList.t_LightIndexList[t_LightIndexStartOffset + i] = t_LightList[i];
    }
}