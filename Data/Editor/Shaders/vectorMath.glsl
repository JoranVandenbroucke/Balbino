#include "mathUtil.glsl"/*    The sum of A and B*/vec3 Add(vec3 v1, vec3 v2){    return v1 + v2;}/*    The difference between A and B.*/vec3 Subtract(vec3 v1, vec3 v2){    return v1 - v2;}/*    The entrywise product of A and B.*/vec3 Multiply(vec3 v1, vec3 v2){    return v1 * v2;}/*    The entrywise division of A by B. Division by zero results in zero.*/vec3 Divide(vec3 v1, vec3 v2){    return SafeDevide( v1, v2 );}/*    The entrywise combination of the multiply and addition operations. */vec3 Multiply Add(vec3 v1, vec3 v2, vec3 v3){    return v1 * v2 + v3;}/*    The cross product of A and B.*/vec3 CrossProduct(vec3 v1, vec3 v2){    return cross( v1, v2);}/*    The projection of A onto B.*/vec3 Project(vec3 v1, vec3 v2){        return dot( v1, v2 ) / length( v2 ) * v2;}/*    The reflection of A around the normal B. B need not be normalized.*/vec3 Reflect(vec3 v1, vec3 v2){    return reflect( v1, v2 );}/*    For a given incident vector A, surface normal B and ratio of indices of refraction (IOR), refract outputs the refraction vector R.*/vec3 Refract(vec3 v1, vec3 v2, float eta){    return refract( v1, v2, eta );}/*    Orients a vector A to point away from a surface B as defined by its normal C. Computes */vec3 Faceforward(vec3 v1, vec3 v2, vec3 v3){    return faceforward( v1, v2, v3 );}    ./*    The dot product of A and B.*/vec3 DotProduct(vec3 v1, vec3 v2){    return dot( v1, v2 );}/*    The distance between A and B.*/vec3 Distance(vec3 v1, vec3 v2){    return distance( v1, v2 );}/*    The length of A.*/vec3 Length(vec3 v1){    return length( v1 );}/*    The result of multiplying A by the scalar input Scale.*/vec3 Scale(vec3 v1, float fac){    return v1 * fac;}/*    The result of normalizing A. The result vector points to the same direction as A and has a length of 1. If A is (0, 0, 0), the result is (0, 0, 0) as well.*/vec3 Normalize(vec3 v1){    return normalize( v1 );}/*    Wrap.*/vec3 Wrap(vec3 v1, vec3 v2, vec3 v3){    return wrap( v1, v2, v3 );}/*    The result of rounding A to the largest integer multiple of B less than or equal A.*/vec3 Snap(vec3 v1, vec3 v2){    return floor(SafeDivide(v1, v2)) * v2;}/*    The entrywise floor of A.*/vec3 Floor(vec3 v1){    return floor(v1);}/*    The entrywise ceiling of A.*/vec3 Ceil(vec3 v1){    return ceil(v1);}/*    The entrywise modulo of A by B.*/vec3 Modulo(vec3 v1, vec3 v2){    return mod(v1, v2);}/*    The fractional part of A.*/vec3 Fraction(vec3 v1){    return v1 - floor(v1);}/*    The entrywise absolute value of A.*/vec3 Absolute(vec3 v1){    return abs(v1);}/*    The entrywise minimum from A and B.*/vec3 Minimum(vec3 v1, vec3 v2){    return min(v1, v2);}/*    The entrywise maximum from A and B.*/vec3 Maximum(vec3 v1, vec3 v2){    return max(v1, v2);}/*    The entrywise Sine of A.*/vec3 Sine(vec3 v1){    return sin(v1);}/*    The entrywise Cosine of A.*/vec3 Cosine(vec3 v1){    return cos(v1);}/*    The entrywise Tangent of A.*/vec3 Tangent(vec3 v1){    return tan(v1);}