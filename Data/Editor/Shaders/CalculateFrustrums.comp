#version 450
#include "CommonInclude.glsl"

#ifndef BLOCK_SIZE
#pragma message( "BLOCK_SIZE undefined. Default to 16.")
#define BLOCK_SIZE 16// should be defined by the application.
#endif

// Global variables
layout(std430, set = 1, binding = 0)readonly buffer DispatchParams
{
// Number of groups dispatched. (This parameter is not available as an HLSL system value!)
    uvec3   numThreadGroups;
// uint padding // implicit padding to 16 bytes.

// Total number of threads dispatched. (Also not available as an HLSL system value!)
// Note: This value may be less than the actual number of threads executed
// if the screen size is not evenly divisible by the block size.
    uvec3   numThreads;
// uint padding // implicit padding to 16 bytes.
};

// View space frustums for the grid cells.
layout(std430, set = 1, binding = 0)buffer oFrustrum
{
    Frustum out_Frustums[];
} outFrustrum;

// The depth from the screen space texture.
layout (rgba32f, binding = 1) uniform image2D DepthTextureVS;
// Precomputed frustums for the grid.
layout(std430, set = 1, binding = 2) buffer iFrustums
{
    Frustum in_Frustums[];
} inFrustrum;

// A kernel to compute frustums for the grid
// This kernel is executed once per grid cell. Each thread
// computes a frustum for a grid cell.
layout(local_size_x = BLOCK_SIZE, local_size_y = BLOCK_SIZE, local_size_z = BLOCK_SIZE)in;
void main()
{
    uvec3 groupID           = gl_WorkGroupID;// 3D index of the thread group in the dispatch.
    uvec3 groupThreadID     = gl_LocalInvocationID;// 3D index of local thread ID in a thread group.
    uvec3 dispatchThreadID  = gl_GlobalInvocationID;// 3D index of global thread ID in the dispatch.
    uint  groupIndex        = gl_LocalInvocationIndex;// Flattened local index of the thread within a thread group.
    
    // View space eye position is always at the origin.
    const vec3 eyePos = vec3(0, 0, 0);
    
    // Compute the 4 corner points on the far clipping plane to use as the
    // frustum vertices.
    vec4 screenSpace[4];
    // Top left point
    screenSpace[0] = vec4(dispatchThreadID.xy * BLOCK_SIZE, -1.0f, 1.0f);
    // Top right point
    screenSpace[1] = vec4(vec2(dispatchThreadID.x + 1, dispatchThreadID.y) * BLOCK_SIZE, -1.0f, 1.0f);
    // Bottom left point
    screenSpace[2] = vec4(vec2(dispatchThreadID.x, dispatchThreadID.y + 1) * BLOCK_SIZE, -1.0f, 1.0f);
    // Bottom right point
    screenSpace[3] = vec4(vec2(dispatchThreadID.x + 1, dispatchThreadID.y + 1) * BLOCK_SIZE, -1.0f, 1.0f);
    
    vec3 viewSpace[4];
    // Now convert the screen space points to view space
    for (int i = 0; i < 4; i++)
    {
        viewSpace[i] = ScreenToView(screenSpace[i]).xyz;
    }
    
    // Now build the frustum planes from the view space points
    Frustum frustum;
    
    // Left plane
    frustum.planes[0] = ComputePlane(eyePos, viewSpace[2], viewSpace[0]);
    // Right plane
    frustum.planes[1] = ComputePlane(eyePos, viewSpace[1], viewSpace[3]);
    // Top plane
    frustum.planes[2] = ComputePlane(eyePos, viewSpace[0], viewSpace[1]);
    // Bottom plane
    frustum.planes[3] = ComputePlane(eyePos, viewSpace[3], viewSpace[2]);
    
    // Store the computed frustum in global memory (if our thread ID is in bounds of the grid).
    if (dispatchThreadID.x < numThreads.x && dispatchThreadID.y < numThreads.y)
    {
        uint index = dispatchThreadID.x + (dispatchThreadID.y * numThreads.x);
        outFrustrum.out_Frustums[index] = frustum;
    }
}