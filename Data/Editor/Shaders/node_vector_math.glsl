#ifndef VECOTR_MATH_GLSL#define VECOTR_MATH_GLSL#include "mathUtil.glsl"/*    The sum of A and B*/void vector_math_add(vec3 v1, vec3 v2, out vec3 v3){    v3 = v1 + v2;}/*    The difference between A and B.*/void vector_math_subtract(vec3 v1, vec3 v2, out vec3 v3, out vec3 v4){    v3 = v1 - v2;}/*    The entrywise product of A and B.*/void vector_math_multiply(vec3 v1, vec3 v2, out vec3 v3){    v3 = v1 * v2;}/*    The entrywise division of A by B. Division by zero results in zero.*/void vector_math_divide(vec3 v1, vec3 v2, out vec3 v3){    v3 = safe_devide( v1, v2 );}/*    The entrywise combination of the multiply and addition operations. */void vector_math_multiplyAdd(vec3 v1, vec3 v2, vec3 v3, out vec3 v4){    v4 = v1 * v2 + v3;}/*    The cross product of A and B.*/void vector_math_cross_product(vec3 v1, vec3 v2, out vec3 v3){    v3 = cross( v1, v2);}/*    The projection of A onto B.*/void vector_math_project(vec3 v1, vec3 v2, out vec3 v3){        v3 = dot( v1, v2 ) / length( v2 ) * v2;}/*    The reflection of A around the normal B. B need not be normalized.*/void vector_math_reflect(vec3 v1, vec3 v2, out vec3 v3){    v3 = reflect( v1, v2 );}/*    For a given incident vector A, surface normal B and ratio of indices of refraction (IOR), refract outputs the refraction vector R.*/void vector_math_refract(vec3 v1, vec3 v2, float eta, out vec3 v3){    v3 = refract( v1, v2, eta );}/*    Orients a vector A to point away from a surface B as defined by its normal C. Computes */void vector_math_faceforward(vec3 v1, vec3 v2, vec3 v3, out vec3 v4){    v4 = faceforward( v1, v2, v3 );}/*    The dot product of A and B.*/void vector_math_dot_product(vec3 v1, vec3 v2, out float v3){    v3 = dot( v1, v2 );}/*    The distance between A and B.*/void vector_math_distance(vec3 v1, vec3 v2, out float v3){    v3 = distance( v1, v2 );}/*    The length of A.*/void vector_math_length(vec3 v1, out float v2){    v3 = length( v1 );}/*    The result of multiplying A by the scalar input Scale.*/void vector_math_scale(vec3 v1, float fac, out vec3 v2){    v2 = v1 * fac;}/*    The result of normalizing A. The result vector points to the same direction as A and has a length of 1. If A is (0, 0, 0), the result is (0, 0, 0) as well.*/void vector_math_normalize(vec3 v1, out vec3 v2){    v2 = normalize( v1 );}/*    Wrap.*/void vector_math_wrap(vec3 v1, vec3 v2, vec3 v3, out vec3 v4){    v4 = wrap( v1, v2, v3 );}/*    The result of rounding A to the largest integer multiple of B less than or equal A.*/void vector_math_snap(vec3 v1, vec3 v2, out vec3 v3){    v3 = floor(safe_divide(v1, v2)) * v2;}/*    The entrywise floor of A.*/void vector_math_floor(vec3 v1, out vec3 v2){    v2 = floor(v1);}/*    The entrywise ceiling of A.*/void vector_math_ceil(vec3 v1, out vec3 v2){    v2 = ceil(v1);}/*    The entrywise modulo of A by B.*/void vector_math_modulo(vec3 v1, vec3 v2, out vec3 v3){    v3 = mod(v1, v2);}/*    The fractional part of A.*/void vector_math_fraction(vec3 v1, out vec3 v2){    v2 = v1 - floor(v1);}/*    The entrywise absolute value of A.*/void vector_math_absolute(vec3 v1, out vec3 v2){    v2 = abs(v1);}/*    The entrywise minimum from A and B.*/void vector_math_minimum(vec3 v1, vec3 v2, out vec3 v3){    v3 = min(v1, v2);}/*    The entrywise maximum from A and B.*/void vector_math_maximum(vec3 v1, vec3 v2, out vec3 v3){    v3 = max(v1, v2);}/*    The entrywise Sine of A.*/void vector_math_sine(vec3 v1, out vec3 v2){    v2 = sin(v1);}/*    The entrywise Cosine of A.*/void vector_math_cosine(vec3 v1, out vec3 v2){    v2 = cos(v1);}/*    The entrywise Tangent of A.*/void vector_math_tangent(vec3 v1, out vec3 v2){    v2 = tan(v1);}#endif  // VECOTR_MATH_GLSL